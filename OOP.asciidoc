How to program with style if you haven't got class
==================================================
Erik Søe Sørensen <eriksoe@gmail.com>

== Square peg, meet round hole ==

[cols="2", width="100%"]
|==================
| I've got this class which I have to implement in Erlang...
| I'm sure it's a nice class :-)

| But Erlang doesn't have a ``class'' concept! What am I to do? How do I implement it in Erlang?
| It depends. What kind of class is it?

| What kinds are there? I'm used to a uniform class concept.
| It may not be as uniform as you think.

| Sure it is. The keyword `class', then a class name, an optional inheritance description, a curly opening brace, then a bunch of definitions... and then a closing brace.
| Semantics matter more than syntax. The syntactic similarities may hide significant semantic differences.

| Such as?
| For instance, some classes are thread-safe, while others are not.
Only some classes are serializable; only some are immutable.
Some don't have any state, and a few are singletons.

For some classes, object identity matters, for others it doesn't.
And only some classes are genuinely designed for inheritance.

Finally, a mutable object may be shared, or there may be just a single reference to it.

| And these differences matter?
| Even under normal circumstances, they matter to some degree.
In a concurrent and possibly distributed setting, they matter a great deal.

| So, what properties determine how I can best represent a concept in Erlang?
| First and foremost: immutability. Does the object have mutable state, or does it contain the same information throughout its lifetime? Numbers, Java strings, and read-only collections are examples of immutable objects.

| OK, let's take an example: the text-book ``Point'' class. Immutable version first -- how would you represent a Point with translation and scaling operations?
a|
Immutable objects are represented as terms. Operations on those objects are represented as functions. A Point, for instance, could be represented as a pair -- a 2-tuple +{X,Y}+:

----------
make_point(X, Y) -> {X,Y}.
scale(T, {X,Y}) -> {T*X, T*Y}.
translate({DX,DY}, {X,Y}) -> {X+DX, Y+DY}.
x_part({X,_}) -> X.
y_part({_,Y}) -> Y.
----------

| That means that objects with the same data will be indistinguishable.
I guess a good thing about that is that I won't need to implement a comparison function (`equals()` in Java).

But what if I want immutable objects with object identity?

a|
Then use `make_ref()` to generate a unique ID, and include that in the data, like so:

----------
make_point(X, Y) -> {make_ref(), X,Y}.
x_part({_,X,_}) -> X.
y_part({_,_,Y}) -> Y.
same({ID1,_,_}, {ID2,_,_}) -> ID1 =:= ID2.
----------

| OK.

By the way: you just added a field to the data type by extending the tuple.
I take it that that's a normal thing to do... but if you need to do that repeatedly, you may end up with tuples of size 10, 20 or more. That must be confusing -- you'd need to be careful to remember the exact position of each field.
| An alternative is to use records (which are tuples under the hood, but with syntactic sugar so that you can ignore all the fields that aren't relevant in a given context.

You'd usually consider switching from raw tuples to records once you get to around 4 or 5 fields.

| How would the Point-with-object identity example look if we were using records, then?
a|
Like so:

----------
-record(point, {id, x, y}).

make_point(X, Y) -> #point{id=make_ref(), x=X, y=Y}.
x_part(#point{x=X}) -> X.
y_part(#point{y=Y}) -> Y.
same({#point{id=ID1}, #point{id=ID2}) -> ID1 =:= ID2.
----------

Or, alternatively:

----------
-record(point, {id, x, y}).

make_point(X, Y) -> #point{id=make_ref(), x=X, y=Y}.
x_part(#point{x=X}) -> X.
y_part(#point{y=Y}) -> Y.
same({#point{id=ID1}, #point{id=ID2}) -> ID1 =:= ID2.
----------

|==================

== Shared mutable state ==

[cols="2", width="100%"]
|==================
| What if I want a mutable version of Point?
| That depends.
Will it be referred to by multiple entities, so that if one of them modifies the Point, that change will be visible by the others?

| For the time being, let's say it's a ``no'' -- that the object only has one referrer.
| Then we can just use the same immutable Point implementation.
Instead of modifying the Point object, we can replace it with a
derived version, and no-one can tell the difference.

| And for a mutable object which is known by more than one entity?
Shared state, you might call it.
| This is where things start to get interesting.

An important part of Erlang program design is figuring out which state there is to keep track of, and where the different pieces of state should be put.
// TODO: About places to put state.

// Primary question:  Is it shared within a thread of execution, or between threads?

// | Then we need a level of indirection. [TODO]
// Possibilities: A process; an ETS row.
|==================

== Subtype Polymorphism ==

[cols="2", width="100%"]
|==================
|==================
