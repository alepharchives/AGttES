How to program with style if you haven't got class
==================================================
Erik Søe Sørensen <eriksoe@gmail.com>

== Square peg, meet round hole ==

[cols="2", width="100%"]
|==================
| I've got this class which I have to implement in Erlang...
| I'm sure it's a nice class :-)

| But Erlang doesn't have a ``class'' concept! What am I to do? How do I implement it in Erlang?
| It depends. What kind of class is it?

| What kinds are there? I'm used to a uniform class concept.
| It may not be as uniform as you think.

| Sure it is. The keyword `class', then a class name, an optional inheritance description, a curly opening brace, then a bunch of definitions... and then a closing brace.
| Semantics matter more than syntax. The syntactic similarities may hide significant semantic differences.

| Such as?
| For instance, some classes are thread-safe, while others are not.
Only some classes are serializable; only some are immutable.
Some don't have any state, and a few are singletons.

For some classes, object identity matters, for others it doesn't.
And only some classes are genuinely designed for inheritance.

Finally, a mutable object may be shared, or there may be just a single reference to it.

| And these differences matter?
| Even under normal circumstances, they matter to some degree.

In a concurrent and possibly distributed setting, they matter a great deal.

| So, what properties determine how I can best represent a concept in Erlang?
| First and foremost: immutability. Does the object have mutable state, or does it contain the same information throughout its lifetime? Numbers, Java strings, and read-only collections are examples of immutable objects.

| OK, let's take an example: the text-book ``Point'' class. Immutable version first -- how would you represent a Point with translation and scaling operations?
a|
Immutable objects are represented as terms. Operations on those objects are represented as functions. A Point, for instance, could be represented as a pair -- a 2-tuple +{X,Y}+:

----------
make_point(X, Y) -> {X,Y}.
scale(T, {X,Y}) -> {T*X, T*Y}.
translate({DX,DY}, {X,Y}) -> {X+DX, Y+DY}.
x_part({X,_}) -> X.
y_part({_,Y}) -> Y.
----------

| That means that objects with the same data will be indistinguishable.
I guess a good thing about that is that I won't need to implement a comparison function (`equals()` in Java).

But what if I want immutable objects with object identity?

a|
Then use `make_ref()` to generate a unique ID, and include that in the data, like so:

----------
make_point(X, Y) -> {make_ref(), X,Y}.
x_part({_,X,_}) -> X.
y_part({_,_,Y}) -> Y.
same({ID1,_,_}, {ID2,_,_}) -> ID1 =:= ID2.
----------

| I see.

By the way: you just added a field to the data type by extending the tuple.
I take it that that's a normal thing to do... but if you need to do that repeatedly, you may end up with tuples of size 10, 20 or more. That must be confusing -- you'd need to be careful to remember the exact position of each field.
| An alternative is to use records (which are tuples under the hood, but with syntactic sugar so that you can ignore all the fields that aren't relevant in a given context.

You'd usually consider switching from raw tuples to records once you get to around 4 or 5 fields.

| How would the Point-with-object identity example look if we were using records, then?
a|
Like so:

----------
-record(point, {id, x, y}).

make_point(X, Y) -> #point{id=make_ref(), x=X, y=Y}.
x_part(#point{x=X}) -> X.
y_part(#point{y=Y}) -> Y.
same(#point{id=ID1}, #point{id=ID2) -> ID1 =:= ID2.
----------

Alternatively, the operations can be written in record-access rather
than pattern-matching style:

----------
x_part(P) -> P#point.x.
y_part(P) -> P#point.y.
same(P1, P2) -> P1#point.id =:= P2#point.id.
----------

| That looks a bit shorter to me. Why bother with pattern matching in this case?
a|
Consider the case where more than one value is extracted from the same record:

----------
scale1(T, #point{x=X, y=Y}) -> {T*X, T*Y}.
scale2(T, P) -> {T*P#point.x, T*P#point.y}.
distance_from_origin1(#point{x=X, y=Y}) -> math:sqrt(X*X + Y*Y).
distance_from_origin2(P) ->
  X = P#point.x,
  Y = P#point.y,
  math:sqrt(X*X + Y*Y).
----------

|==================

== Shared mutable state ==

[cols="2", width="100%"]
|==================
| What if I want a mutable version of Point?
| That depends.
Will it be referred to by multiple entities, so that if one of them modifies the Point, that change will be visible by the others?

| For the time being, let's say it's a ``no'' -- that the object only has one referrer.
| Then we can just use the same immutable Point implementation.
Instead of modifying the Point object, we can replace it with a
derived version, and no-one can tell the difference.

| And for a mutable object which is known by more than one entity?
Shared state, you might call it.
| Then we need a level of indirection.

| OK, so instead of storing the data, you store a reference to the data.
And then you store the actual data somewhere else.
| Yes. (That effectively reduces the ``multiple entities'' back into a single one.)

The ``somewhere else'' could be another functional (immutable) data
structure, but more often, the reference in question is a reference to
a table or a process.

| Ah. So now we're getting beyond a single, purely-functional process.
| We are, and this is where things start to get interesting.

An important part of Erlang program design is figuring out which state there is to keep track of, and where the different pieces of state should be put.

| In a typical OOP language, state lives in the instance fields of objects, and the static fields or global variables or whatever the language's got.
Oh, and of course in the local variables on the program stack.
| In Erlang, the local variables on the stack are the primary place for state.
Pure functional language have just that.

But Erlang's also got the process dictionary, ETS tables, and (for special purposes) the global registries of named processes and tables.

And, of course, processes -- one of the possible raison d'être's of a process is ``to hold some state''.

// (For cheating, you can also tuck away state in device drivers and native functions.)

| When do you use what? What kinds of state go where?
| You normally keep it in local variables.
Constants can stay in code.

Shared mutable state, however, usually take the form of either processes or tables. (More rarely, the process dictionary comes into use.)

For singletons and truly global mutable state, you use named processes and tables.

Tables are also used for some kinds of mutable data which aren't shared -- which could in principle just be stored in functional data structures.

| Which kinds of data is that?
| Collections which often grow large, or which have elements which are typically more or less constant over a long time, fit well into ETS tables.

It also helps if the data has a primary key.

| What are the advantages of tables?
| One advantage is certainly constant lookup time (in unordered tables) when the primary key is known.

And the reason tables are a good place to put large or slowly-mutating data sets is that it keeps it out of a process's heap, out of the way of the garbage collector.

The major difference between normal functional data structures and ETS table is that tables perform destructive (in-place) updates.
That means that you can't keep the old version of the table around --
on the other hand, it means that you don't need to thread the current
value of the data structure, which may at times lead to a simpler program structure.

Also, tables can be named, and they can (if needed) be accessed -- safely -- by more than one process.

| What of the drawbacks?
| There are a few -- tables don't fit all kinds of data and access patterns; as just mentioned, they're not persistent, but updated destructively; they can't be serialized or used across nodes in a distributed system; and there's a limit to how many of them you can have at the same time.

And because they're separate from the process heaps, data must be copied into and out of them, so data access is a bit less direct than for data on the heap.

| Suppose I have some shared mutable state.
How do I determine where to put it?
| The primary question is: Is it shared _within_ a thread of
  execution, or _between_ threads?

If it is shared just within a single process, then it's probably fit
to put into a table.  Especially if there's more than one of the items in question.

| And if I'm sharing it between processes?
| If data is shared between processes, then you need a process to hold it
(which may be one of the existing processes, when that makes sense).

That process will then handle get- and set-requests, or whatever
operations are suitable.

A process which holds many items in that way can of course do so by
storing them in one or more tables.

| So, for our shared mutable Point example: if it's shared within a
  process, I can a) share a reference to it and keep the mutable value in a separate data structure; b) that data structure can be an ETS table.

Or c) -- which works also for sharing between processes - I can make the Point into a process of its own, with getter and setter calls etc.
| Or d) you decide that a single point is too light-weight to make into a process of its own, so you make a Point server process which keeps track of the state of whole lot of points.

| But if there are many Points users, but only one such Point server,
it might turn into a bottleneck.

You mentioned that multiple processes can access one table?

| Yes; a table can be private to a process, or other processes can be
  allowed to either just read from it, or have both read and write
  access to it.

For information that is read-heavy, for instance, it may make sense to
allow other processes to read directly from the table, rather than to
force the process owning the table to service all of the requests
pertaining to the table sequentially (which might make that process a
bottleneck in the system).

| And when wouldn't I want to do that?
| Whether such an approach makes sense, depends on
  whether the kinds of transactions which are needed are supported by
  the ETS tables.

  All ETS operations on individual rows are atomic.
  You can even do an atomic addition or subtraction on a single cell,
  or adjust multiple cells in the same row by constant offsets.

| So in such cases I need not worry about race conditions, even if
  multiple processes access the table concurrently.
| No; ETS is thread-safe and provides explicit atomicity guarantees.

  But transactions which involve more than one row, and most kinds of
  transactions which involve both reads and writes, cannot be done
  atomically.  So if you need such operations, you probably can't let
  the table be accessed by more than one process.

|====================


== Subtype Polymorphism ==

[cols="2", width="100%"]
|==================
|==================
